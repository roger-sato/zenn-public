---
title: "äººå–°ã„ã¨å®£æ•™å¸«å•é¡Œã‚’Rustã§è§£ã"
emoji: "ğŸ§Ÿ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Rust"]
published: true
---

## äººå–°ã„ã¨å®£æ•™å¸«å•é¡Œ
ã€Œäººå–°ã„ã¨å®£æ•™å¸«å•é¡Œã€ã¯ã€è«–ç†ãƒ‘ã‚ºãƒ«ã®ä¸€ç¨®ã§ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‚µã‚¤ã‚¨ãƒ³ã‚¹ã®åˆ†é‡ã§ã‚ˆãä½¿ã‚ã‚Œã‚‹å•é¡Œã§ã™ã€‚
ã“ã®å•é¡Œã®ç›®çš„ã¯ã€ä¸€å®šã®åˆ¶ç´„ã®ä¸‹ã§å…¨ã¦ã®äººã‚’å·ã®å‘ã“ã†å²¸ã«å®‰å…¨ã«é‹ã¶ã“ã¨ã§ã™ã€‚

å•é¡Œã®è¨­å®šã¯æ¬¡ã®é€šã‚Šã§ã™ï¼š
- å·ã®ä¸€æ–¹ã®å²¸ã«ã¯3äººã®å®£æ•™å¸«ã¨3äººã®äººå–°ã„ãŒã„ã¾ã™
- ã‚ãªãŸã®ç›®çš„ã¯ã€å…¨å“¡ã‚’ãƒœãƒ¼ãƒˆã‚’ä½¿ã£ã¦å·ã®å‘ã“ã†å²¸ã«é‹ã¶ã“ã¨ã§ã™
- ãƒœãƒ¼ãƒˆã«ã¯æœ€å¤§ã§2äººã¾ã§ã—ã‹ä¹—ã›ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“
- ã©ã“ã«ã„ã¦ã‚‚ã€äººå–°ã„ã®æ•°ãŒå®£æ•™å¸«ã®æ•°ã‚’ä¸Šå›ã‚‹ã¨ã€å®£æ•™å¸«ãŒé£Ÿã¹ã‚‰ã‚Œã¦ã—ã¾ã„ã¾ã™

9å¹´å‰ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’å­¦ã³å§‹ã‚ãŸã¨ãã«ã‚‚å‹‰å¼·ã¨ã—ã¦è§£ã„ãŸã®ã§ã™ãŒ([è§£ã„ãŸæ™‚ã®è¨˜äº‹](https://qiita.com/lovablepleiad/items/9ba7b8f4de96654fc0dd))

ä»Šå›ã¯äººæ•°ã®éƒ¨åˆ†ã‚’ä»»æ„ã®æ•´æ•°ã«ã—ãŸã‚‚ã®ã‚’è§£ã„ã¦ã¿ã¾ã™ã€‚

ã‚³ãƒ¼ãƒ‰ã¯ã“ã“ã«ç½®ã„ã¦ã¾ã™ã€‚[Github](https://github.com/roger-sato/missionaries-and-cannibals-problem)

è‰²ã€…ãªè§£ãæ–¹ã¯ã‚ã‚‹ã®ã§ã™ãŒã€ã“ã®è¨˜äº‹ã§ã¯æ·±ã•å„ªå…ˆæ¢ç´¢ã¨A*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§è§£ã„ã¦ã¿ã¾ã™ã€‚

æ·±ã•å„ªå…ˆæ¢ç´¢ã¯å…¨æ¢ç´¢ã®ä¸€ç¨®ã§ã€å–ã‚Šã†ã‚‹é¸æŠè‚¢ã‚’ã™ã¹ã¦è©¦ã—ã¦ã„ãã¾ã™ã€‚
A*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ç¾åœ¨åœ°ç‚¹ã‹ã‚‰ç›®çš„åœ°ã¾ã§è©•ä¾¡é–¢æ•°ã¨ã—ã¦å®šç¾©ã—ã¦ã€è©•ä¾¡é–¢æ•°ãŒå°ã•ã„(ã‚ã‚‹ã„ã¯å¤§ãã„)ã‚‚ã®ã‚’å„ªå…ˆçš„ã«é¸ã‚“ã§ã„ããƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯æ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã™ã€‚
A*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯é©åˆ‡ãªè©•ä¾¡é–¢æ•°ã‚’å®šç¾©ã§ãã‚Œã°åŠ¹ç‡ã®è‰¯ã„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã™ãŒã€ãã†ã§ãªã„å ´åˆã¯éå¸¸ã«åŠ¹ç‡ã®æ‚ªã„æ¢ç´¢ã«ãªã£ã¦ã—ã¾ã†å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

ã¾ãšã¯ã€Stateæ§‹é€ ä½“ã‚’å®šç¾©ã—ã¾ã™ã€‚
Stateæ§‹é€ ä½“ã¯ã‚ã‚‹æ™‚ç‚¹ã§ã®äººå–°ã„ã¨å®£æ•™å¸«ã¨ãƒœãƒ¼ãƒˆã®é…ç½®ã‚’ç¤ºã—ã¦ã¾ã™ã€‚

```rust
#[derive(Clone, Eq, Ord, PartialEq)]
struct State {
    cannibals_left: i64, // å·¦å²¸ã«ã„ã‚‹äººå–°ã„ã®æ•°
    missionaries_left: i64, // å·¦å²¸ã«ã„ã‚‹å®£æ•™å¸«ã®æ•°
    boat_left: bool, // ãƒœãƒ¼ãƒˆãŒå·¦å´ã«ã‚ã‚Œã°true,ãã†ã§ãªã„å ´åˆã¯false
}
```

ãã—ã¦ã€Stateã¯ã„ãã¤ã‹ã®Traitã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ãŒã€ã•ã‚‰ã«PartialOrdã¨Hashã‚‚ç‹¬è‡ªå®Ÿè£…ã—ã¾ã™ã€‚

```rust
impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
        Some(
            score(self.cannibals_left, self.missionaries_left)
                .cmp(&score(other.cannibals_left, other.missionaries_left))
                .reverse(),
        )
    }
}

impl Hash for State {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.cannibals_left.hash(state);
        self.missionaries_left.hash(state);
        self.boat_left.hash(state);
    }
}
```

PartialOrdã§ã¯ã€scoreé–¢æ•°ã«åŸºã¥ã„ã¦ä¸¦ã³æ›¿ãˆã‚’è¡Œã£ã¦ã„ã¾ã™ãŒã€ã“ã®scoreé–¢æ•°ãŒA*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®è©•ä¾¡é–¢æ•°ã¨ãªã‚Šã¾ã™ã€‚
ä»Šå›ã¯å·¦å²¸ã«ã„ã‚‹äººå–°ã„ã¨å®£æ•™å¸«ã®åˆè¨ˆå€¤ã‚’ã‚³ã‚¹ãƒˆã¨ã—ã¦è©•ä¾¡ã—ã¦ã„ã¾ã™ã€‚
æ¢ç´¢é–‹å§‹åœ°ç‚¹ã§ã¯æœ€ã‚‚ã“ã®åˆè¨ˆå€¤ãŒé«˜ãã€ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã§ã¯0ã«ãªã‚Šã€ã‚´ãƒ¼ãƒ«ã«è¿‘ã¥ãã«å¾“ã£ã¦ã»ã¼å˜èª¿çš„ã«æ¸›å°‘ã™ã‚‹ãŸã‚ã§ã™ã€‚
ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã¥ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

```rust
fn score(cannibals_left: i64, missionaries_left: i64) -> i64 {
    cannibals_left + missionaries_left
}
```

ã¾ãŸã€æ·±ã•å„ªå…ˆæ¢ç´¢ã¨A*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æŒ™å‹•ã‚’å¤‰ãˆã‚‹æ–¹æ³•ã¨ã—ã¦ã€Stateã‚’ä¿å­˜ã™ã‚‹ã®ã«ã©ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’é¸ã¶ã‹ã‚’æ±ºã‚ã¦ã„ã¾ã™ã€‚
Rustã§ã¯Vecå‹ã‚’ä½¿ãˆã°æ·±ã•å„ªå…ˆæ¢ç´¢ã«ã€BinaryHeapå‹ã‚’ä½¿ãˆã°A*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ãªã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚
ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡ã‚’ãªãã™ãŸã‚ã«ã€StateQueue traitã‚’ä½œæˆã—ã¦ã€ã©ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’åˆ©ç”¨ã™ã‚‹ã‹ã‚’ä¸€èˆ¬åŒ–ã—ã¦ã„ã¾ã™ã€‚
StateQueueã¯ã€push,pop,is_emptyãŒå®šç¾©ã•ã‚Œã¦ãŠã‚Šã€Vec<State>ã¨BinaryHeap<State>ã«å¯¾ã—ã¦ãã‚Œãã‚Œå®Ÿè£…ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚

```rust
trait StateQueue {
    fn push(&mut self, state: State);
    fn pop(&mut self) -> Option<State>;
    fn is_empty(&self) -> bool;
}

impl StateQueue for Vec<State> {
    fn push(&mut self, state: State) {
        self.push(state);
    }
    fn pop(&mut self) -> Option<State> {
        self.pop()
    }
    fn is_empty(&self) -> bool {
        self.is_empty()
    }
}

impl StateQueue for BinaryHeap<State> {
    fn push(&mut self, state: State) {
        self.push(state);
    }
    fn pop(&mut self) -> Option<State> {
        self.pop()
    }
    fn is_empty(&self) -> bool {
        self.is_empty()
    }
}
```


æ¬¡ã«å®Ÿéš›ã«å•é¡Œã‚’è§£ãã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã¾ã™ã€‚
å¤§ã¾ã‹ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã“ã‚“ãªæ„Ÿã˜ã§ã™ã€‚

1. åˆæœŸã®çŠ¶æ…‹ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‹
2. ã‚­ãƒ¥ãƒ¼ãŒç©ºã§ãªã„ã¨ãã€ã‚­ãƒ¥ãƒ¼ã‹ã‚‰çŠ¶æ…‹ã‚’1ã¤å–ã‚Šå‡ºã™ã€‚æ®»ã§ã‚ã‚‹ã¨ãã¯ã€ç©ºã®è§£ã‚’è¿”ã—ã¦çµ‚äº†ã™ã‚‹
3. å–ã‚Šå‡ºã—ãŸçŠ¶æ…‹ãŒã‚´ãƒ¼ãƒ«ã§ã‚ã‚‹ãªã‚‰ã°ã€éå»ã®è¡Œå‹•å±¥æ­´ã‚’è¿”ã—ã¦çµ‚äº†ã™ã‚‹
4. å–ã‚Šå‡ºã—ãŸçŠ¶æ…‹ã‹ã‚‰ã®é·ç§»(ãƒœãƒ¼ãƒˆã«èª°ã‚’ã©ã‚Œã ã‘ä¹—ã›ã‚‹ã‹)ã‚’ã™ã¹ã¦åˆ—æŒ™ã™ã‚‹
5. é·ç§»å…ˆã®çŠ¶æ…‹ãŒéå»ã«å®Ÿè¡Œã•ã‚Œã¦ã„ãªãã€äººå–°ã„ãŒå®£æ•™è€…ã‚ˆã‚Šã‚‚å¤šã„çŠ¶æ³ãŒãªã„å ´åˆã¯ã‚­ãƒ¥ãƒ¼ã«è©°ã‚ã‚‹
5. æ–°ã—ã„é·ç§»å…ˆã®çŠ¶æ…‹ã«å¯¾ã—ã¦è¡Œå‹•å±¥æ­´ã‚’è¿½åŠ ã™ã‚‹
6. 2ã«æˆ»ã‚‹

```rust
fn solve<T: Default + StateQueue>(
    cannibals_num: i64, // äººå–°ã„ã®æ•°
    missionaries_num: i64, // å®£æ•™å¸«ã®æ•°
    boat_capacity: i64, // ãƒœãƒ¼ãƒˆã«ä¹—ã‚‹ã“ã¨ã®ã§ãã‚‹æ•°
) -> Option<Vec<BoatMovement>> {
    // åˆæœŸçŠ¶æ…‹
    let state = State {
        cannibals_left: cannibals_num,
        missionaries_left: missionaries_num,
        boat_left: true,
    };

    // ç§»å‹•ã—ãŸçµæœã‚’ä¿æŒ
    let mut history: HashMap<State, Vec<BoatMovement>> = HashMap::new();

    // Stateã‚­ãƒ¥ãƒ¼
    let mut queue = T::default();

    queue.push(state.clone());

    while !queue.is_empty() {
        let state = queue.pop().unwrap();
        let cannibals_left = state.cannibals_left;
        let missionaries_left = state.missionaries_left;
        let cannibals_right = cannibals_num - cannibals_left;
        let missionaries_right = missionaries_num - missionaries_left;

        if cannibals_left == 0 && missionaries_left == 0 && !state.boat_left {
            return history.get(&state).map(|value| value.clone());
        }

        let max_cannibals_on_boat = if state.boat_left {
            cmp::min(boat_capacity, cannibals_left)
        } else {
            cmp::min(boat_capacity, cannibals_right)
        };

        let max_missionaries_on_boat = |cannibals_boat: i64| {
            if state.boat_left {
                cmp::min(boat_capacity - cannibals_boat, missionaries_left)
            } else {
                cmp::min(boat_capacity - cannibals_boat, missionaries_right)
            }
        };

        for cannibals_boat in 0..=max_cannibals_on_boat {
            for missionaries_boat in 0..=max_missionaries_on_boat(cannibals_boat) {
                if cannibals_boat + missionaries_boat == 0 {
                    continue;
                }

                fn update_counts(left: i64, right: i64, boat: i64, boat_left: bool) -> (i64, i64) {
                    if boat_left {
                        (left - boat, right + boat)
                    } else {
                        (left + boat, right - boat)
                    }
                }

                let (next_cannibals_left, next_cannibals_right) = update_counts(
                    cannibals_left,
                    cannibals_right,
                    cannibals_boat,
                    state.boat_left,
                );
                let (next_missionaries_left, next_missionaries_right) = update_counts(
                    missionaries_left,
                    missionaries_right,
                    missionaries_boat,
                    state.boat_left,
                );

                if !validate_cannibal_missionary_balance(ValidateCannibalMissionaryBalanceProp {
                    cannibals_left: next_cannibals_left,
                    missionaries_left: next_missionaries_left,
                    cannibals_right: next_cannibals_right,
                    missionaries_right: next_missionaries_right,
                    cannibals_boat,
                    missionaries_boat,
                }) {
                    continue;
                }

                let next_state = State {
                    cannibals_left: next_cannibals_left,
                    missionaries_left: next_missionaries_left,
                    boat_left: !state.boat_left,
                };

                // å®Ÿè¡Œã®åŠ¹ç‡åŒ–ã®ãŸã‚ã«ã€ã™ã§ã«è¨ªã‚ŒãŸçŠ¶æ…‹ã§ã‚ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹
                // ãŸã ã—ã€å®Ÿè¡Œå±¥æ­´ãŒå¤šã„å ´åˆã¯å†è¨ˆç®—ã‚’è¡Œã†
                if history.contains_key(&next_state)
                    && history.get(&next_state).unwrap().len() <= history.get(&state).unwrap().len()
                {
                    continue;
                }

                let mut next_history = match history.get(&state) {
                    Some(value) => value.clone(),
                    None => Vec::new(),
                };
                next_history.push(BoatMovement {
                    cannibals_boat,
                    missionaries_boat,
                    move_right: state.boat_left,
                });
                history.insert(next_state.clone(), next_history.clone());

                queue.push(next_state);
            }
        }
    }
    return None;
}
```

æœ€å¾Œã«ã“ã‚“ãªæ„Ÿã˜ä½¿ã„ã¾ã™ã€‚

```rust
fn main() {
    let cannibals = 3;
    let missionaries = 3;
    let boat_capacity = 2;

    let result_vec = solve::<Vec<State>>(cannibals, missionaries, boat_capacity);
    let result_heap = solve::<BinaryHeap<State>>(cannibals, missionaries, boat_capacity);
    match result_vec {
        Some(history) => {
            println!("Found solution! With Vec<State>");
            println!("===========================================================");
            println!("ğŸ§Ÿ = cannibal");
            println!("ğŸ˜‡ = missionary");
            println!("===========================================================");
            println!();
            println!("step counts: {}", history.len());
            print_history(&history);
        }
        None => {
            println!("===========================================================");
            println!("No solution found!");
            println!("===========================================================");
        }
    }
    match result_heap {
        Some(history) => {
            println!("Found solution! With BinaryHeap<State>");
            println!("===========================================================");
            println!("ğŸ§Ÿ = cannibal");
            println!("ğŸ˜‡ = missionary");
            println!("===========================================================");
            println!();
            println!("step counts: {}", history.len());
            print_history(&history);
        }
        None => {
            println!("===========================================================");
            println!("No solution found!");
            println!("===========================================================");
        }
    }
}
```

print_historyã¯è¡Œå‹•å±¥æ­´ã‚’å‡ºåŠ›ã™ã‚‹é–¢æ•°ã§ä»¥ä¸‹ã®é€šã‚Šã§ã™

```rust
fn print_history(history: &Vec<BoatMovement>) {
    for action in history.iter() {
        println!("===========================================================");
        if action.move_right {
            println!(
                "(â†’) move right with {} ğŸ§Ÿ and {} ğŸ˜‡",
                action.cannibals_boat, action.missionaries_boat
            );
        } else {
            println!(
                "(â†) move left with {} ğŸ§Ÿ and {} ğŸ˜‡",
                action.cannibals_boat, action.missionaries_boat
            );
        }
        println!("===========================================================");
        println!();
    }
}
```

äººå–°ã„ãŒ3äººã€å®£æ•™å¸«3äººã€ãƒœãƒ¼ãƒˆã«ä¹—ã‚Œã‚‹æ•°ã‚’2äººã§å®Ÿè¡Œã™ã‚‹ã¨æ¬¡ã®é€šã‚Šã«ãªã‚Šã¾ã™ã€‚

```
Found solution! With Vec<State>
===========================================================
ğŸ§Ÿ = cannibal
ğŸ˜‡ = missionary
===========================================================

step counts: 11
===========================================================
(â†’) move right with 2 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 2 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 0 ğŸ§Ÿ and 2 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 1 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 0 ğŸ§Ÿ and 2 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 2 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 2 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

Found solution! With BinaryHeap<State>
===========================================================
ğŸ§Ÿ = cannibal
ğŸ˜‡ = missionary
===========================================================

step counts: 11
===========================================================
(â†’) move right with 2 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 2 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 0 ğŸ§Ÿ and 2 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 1 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 0 ğŸ§Ÿ and 2 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 1 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 2 ğŸ§Ÿ and 0 ğŸ˜‡
===========================================================

===========================================================
(â†) move left with 0 ğŸ§Ÿ and 1 ğŸ˜‡
===========================================================

===========================================================
(â†’) move right with 1 ğŸ§Ÿ and 1 ğŸ˜‡
===========================================================
```

ã“ã®ã‚±ãƒ¼ã‚¹ã ã¨ã€‚æ·±ã•å„ªå…ˆæ¢ç´¢ã¨A*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ã‚¹ãƒ†ãƒƒãƒ—æ•°ã¯åŒã˜11ã«ãªã£ã¦ã¾ã™ã€‚
äººå–°ã„ãŒ50äººã€å®£æ•™å¸«50äººã€ãƒœãƒ¼ãƒˆã«ä¹—ã‚Œã‚‹æ•°ã‚’10äººã§å®Ÿè¡Œã™ã‚‹ã¨æ¬¡ã®é€šã‚Šã«ãªã‚Šã¾ã™ã€‚

```
Found solution! With Vec<State>
step counts: 37

Found solution! With BinaryHeap<State>
step counts: 25
```

ã“ã®ã‚±ãƒ¼ã‚¹ã«ã™ã‚‹ã¨A*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æ–¹ãŒã‚¹ãƒ†ãƒƒãƒ—æ•°ãŒå°ã•ããªã‚Šã¾ã—ãŸã€‚

### ãŠã‚ã‚Šã«

Rustã®å­¦ç¿’ã¨ã—ã¦æ›¸ãã¾ã—ãŸã€‚
ã‚‚ã£ã¨ã„ã„æ›¸ãæ–¹ãŒã‚ã‚Œã°æ•™ãˆã¦ãã‚Œã‚‹ã¨ã™ã”ãå–œã³ã¾ã™ã€‚
